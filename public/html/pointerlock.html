<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    html,
    body {
        width: 100%;
        height: 100%;
    }
    
    body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        font-family: arial;
    }
    
    #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
    }
    
    #instructions {
        width: 100%;
        height: 100%;
        display: -webkit-box;
        display: -moz-box;
        display: box;
        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;
        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;
        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;
        color: #ffffff;
        text-align: center;
        cursor: pointer;
    }
    </style>
</head>

<body>
    <script src="../js/lib/three.js"></script>
    <script src="../js/animation/controls/PointerLockControls.js"></script>
    <script src="../js/animation/crossfade/scenes.js"></script>

    <script>
    var camera, scene, renderer;
    var geometry, material, mesh;
    var controls;
    var objects = [];
    // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
    var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    if (havePointerLock) {
        var element = document.body;
        var pointerlockchange = function(event) {
            if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                controls.enabled = true;
            } else {
               controls.enabled = false;

            }
        };

        // Hook pointer lock state change events
        document.addEventListener('pointerlockchange', pointerlockchange, false);
        document.addEventListener('mozpointerlockchange', pointerlockchange, false);
        document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

    } else {
        alert('Your browser doesn\'t seem to support Pointer Lock API');
    }
    var mouse = new THREE.Vector2();
    var INTERSECTED;

    init();
    animate();



    function init() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        controls = new THREE.PointerLockControls(camera);

        scene = new THREE.Scene();
       //       var  sceneA = new Scene("mainScene", 5000, 1200, 120, new THREE.Vector3(0, -0.4, 0), 0xffffff,controls,camera);

        scene.fog = new THREE.Fog(0xffffff, 0, 750);
        var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);
        scene.add(controls.getObject());

        // floor
        geometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        geometry.rotateX(-Math.PI / 2);
        for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            vertex.x += Math.random() * 20 - 10;
            vertex.y += Math.random() * 2;
            vertex.z += Math.random() * 20 - 10;
        }
        for (var i = 0, l = geometry.faces.length; i < l; i++) {
            var face = geometry.faces[i];
            face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
        }
        material = new THREE.MeshBasicMaterial({
            vertexColors: THREE.VertexColors
        });
        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        // objects
        geometry = new THREE.BoxGeometry(20, 20, 20);
        for (var i = 0, l = geometry.faces.length; i < l; i++) {
            var face = geometry.faces[i];
            face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
        }
        for (var i = 0; i < 4; i++) {
            material = new THREE.MeshPhongMaterial({
                specular: 0xffffff,
                shading: THREE.FlatShading,
                vertexColors: THREE.VertexColors
            });
            var mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = i * 20;
            mesh.position.y =  11;
            mesh.position.z = i * 20;
            scene.add(mesh);
            material.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            objects.push(mesh);
        }
        //
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        document.addEventListener('mousemove', onDocumentMouseMove, false);

        //
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function animate() {
        requestAnimationFrame(animate);
        var raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

        raycaster.ray.origin.copy(controls.getObject().position);
        raycaster.ray.origin.y -= 10;
        var intersections = raycaster.intersectObjects(objects);
        var isOnObject = intersections.length > 0;
        raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 100);

        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
            if (INTERSECTED != intersects[0].object) {
                if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
                INTERSECTED = intersects[0].object;
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex(0xff0000);
            }
        } else {
            if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
            INTERSECTED = null;
        }
        controls.update();


        renderer.render(scene, camera);
    }
    </script>
</body>

</html>
